From 17dbca59898c27452cd5e605a470fb4ee2348598 Mon, 10 Oct 2016 16:03:40 +0200
From: Thomas Perl <thomas.perl@jolla.com>
Date: Wed, 5 Mar 2014 14:34:17 +0100
Subject: [PATCH] [transaction] Builtin policy and whitelist. Contributes to JB#14776


diff --git a/src/pk-transaction.c b/src/pk-transaction.c
index 886cb0c..ec154c7 100644
--- a/src/pk-transaction.c
+++ b/src/pk-transaction.c
@@ -2832,6 +2832,87 @@
 }
 
 /**
+ * Built-in policy configuration until we get a newer polkit with JS-based
+ * rules that can handle fine-grained policy decisions based on the sender
+ **/
+static gboolean
+pk_transaction_builtin_policy_allow (guint pid)
+{
+	GError *error = NULL;
+	gboolean result = FALSE;
+	gchar *path = g_strdup_printf ("/proc/%u", pid);
+	gchar *exec = g_strdup_printf ("/proc/%u/exe", pid);
+	const gchar *exec_whitelist[] = {
+		// For system upgrades (remove this one once new systemd lands)
+		"/usr/bin/store-client",
+
+		// For devel dist upgrading
+		"/usr/bin/devel-dist-upgrade",
+
+		// For deploying RPMs from the SDK
+		"/usr/bin/devel-deploy-rpm",
+
+		NULL,
+	};
+	const gchar *egid_whitelist[] = {
+		// Privileged applications
+		"privileged",
+
+		NULL,
+	};
+	int i = 0;
+	gchar *app = NULL;
+
+	// Check if a systemd-style system update is in progress
+	// http://www.freedesktop.org/wiki/Software/systemd/SystemUpdates/
+	struct stat update_stat;
+	if (stat("/system-update", &update_stat) == 0) {
+		g_debug ("System update in progress - allowing request");
+		result = TRUE;
+	}
+
+	// Check application executable path of sender process
+	app = g_file_read_link (exec, &error);
+	if (app) {
+		g_debug ("Executable of sender process: '%s'", app);
+		for (i=0; exec_whitelist[i]; i++) {
+			if (g_strcmp0 (app, exec_whitelist[i]) == 0) {
+				g_debug ("Allowing from exec whitelist");
+				result = TRUE;
+				break;
+			}
+		}
+		g_free (app);
+	} else {
+		g_warning ("Could not get executable of sender process: %s",
+				error->message);
+		g_error_free (error);
+	}
+
+	// Check effective group ID of sender process
+	struct stat sender_stat;
+	if (stat(path, &sender_stat) == 0) {
+		struct group *sender_group = getgrgid (sender_stat.st_gid);
+		if (sender_group) {
+			g_debug ("Group of sender process: '%s'", sender_group->gr_name);
+                        for (i=0; egid_whitelist[i]; i++) {
+				if (g_strcmp0 (sender_group->gr_name, egid_whitelist[i]) == 0) {
+					g_debug ("Allowing from egid whitelist");
+					result = TRUE;
+				}
+			}
+		}
+	}
+
+	g_free (exec);
+	g_free (path);
+
+	g_debug ("%s -> %s", __func__, result ? "true" : "false");
+
+	return result;
+}
+
+/**
  * pk_transaction_obtain_authorization:
  *
  * Only valid from an async caller, which is fine, as we won't prompt the user
@@ -2856,27 +2937,14 @@
 
 	g_return_val_if_fail (priv->sender != NULL, FALSE);
 
-	/* setgid privileged processes don't need additional authentication */
-	guint pid = pk_dbus_get_pid (priv->dbus, priv->sender);
-	gchar *path = g_strdup_printf ("/proc/%u", pid);
-	struct stat sender_stat;
-	if (stat(path, &sender_stat) == 0) {
-		struct group *sender_group = getgrgid (sender_stat.st_gid);
-		if (sender_group) {
-			g_debug ("Group of sender process: '%s'", sender_group->gr_name);
-			if (g_strcmp0 (sender_group->gr_name, "privileged") == 0) {
-				priv->skip_auth_check = TRUE;
-			}
-		}
-	}
-	g_free (path);
-
 	/* we don't need to authenticate at all to just download
 	 * packages or if we're running unit tests */
 	if (pk_bitfield_contain (transaction->priv->cached_transaction_flags,
 				 PK_TRANSACTION_FLAG_ENUM_ONLY_DOWNLOAD) ||
 	    pk_bitfield_contain (transaction->priv->cached_transaction_flags,
 				 PK_TRANSACTION_FLAG_ENUM_SIMULATE) ||
+	    pk_transaction_builtin_policy_allow (pk_dbus_get_pid (priv->dbus,
+			    priv->sender)) ||
 	    priv->skip_auth_check == TRUE) {
 		g_debug ("No authentication required");
 		ret = pk_transaction_commit (transaction);
