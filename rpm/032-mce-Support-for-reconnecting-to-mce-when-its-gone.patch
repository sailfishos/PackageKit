From 7959b388831a321b01a0d50dd5baf847c914c60b Mon, 10 Oct 2016 16:02:13 +0200
From: Thomas Perl <thomas.perl@jolla.com>
Date: Fri, 10 Jan 2014 13:37:34 +0100
Subject: [PATCH] [mce] Support for reconnecting to mce when it's gone


To test, start PackageKit as root user in verbose mode:

     /usr/libexec/packagekitd --verbose

In another session as root, stop mce temporarily:

     systemctl stop mce.service

In yet another session as user, ask PackageKit to do something:

     pkcon refresh

In the first session where packagekitd is running in verbose mode,
it will wait for mce to come back (and try evert 5 seconds to do so)
and print warnings while it fails. After restarting mce, PackageKit
can successfully connect to mce again:

     systemctl start mce.service

diff --git a/src/pk-engine.c b/src/pk-engine.c
index 50b8977..4c13bf5 100644
--- a/src/pk-engine.c
+++ b/src/pk-engine.c
@@ -108,7 +108,6 @@
 	gint			 logind_fd;
 #endif
 #ifdef PK_BUILD_MCE
-	GDBusProxy		*mce_proxy;
 	GThread			*mce_thread;
 	gboolean		 mce_thread_active;
 	GMutex			 mce_mutex;
@@ -176,100 +175,186 @@
 }
 
 #ifdef PK_BUILD_MCE
-static gpointer
-mce_keepalive_thread_func (gpointer data)
+static GDBusProxy *
+mce_keepalive_connect (GDBusConnection *connection)
 {
-	PkEngine *engine = PK_ENGINE (data);
-	GVariant *res = NULL;
 	GError *error = NULL;
 
-	res = g_dbus_proxy_call_sync (engine->priv->mce_proxy,
-			MCE_CPU_KEEPALIVE_PERIOD_REQ,
+	/* connect to mce */
+	GDBusProxy *proxy = g_dbus_proxy_new_sync (connection,
+			G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,
 			NULL,
-			G_DBUS_CALL_FLAGS_NONE,
-			-1,
-			NULL,
+			MCE_SERVICE,
+			MCE_REQUEST_PATH,
+			MCE_REQUEST_IF,
+			NULL, /* GCancellable */
 			&error);
+
+	if (proxy == NULL) {
+		g_warning ("Failed to connect to mce: %s", error->message);
+		g_error_free (error);
+	}
+
+	return proxy;
+}
+
+static gboolean
+mce_keepalive_send (GDBusProxy *proxy, const char *message)
+{
+	GError *error = NULL;
+	GVariant *res = g_dbus_proxy_call_sync (proxy, message,
+			NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error);
+
+	if (res == NULL) {
+		g_warning ("Failed to send %s to mce: %s", message, error->message);
+		g_error_free (error);
+		return FALSE;
+	}
+
+	g_variant_unref (res);
+	return TRUE;
+}
+
+static gint32
+mce_keepalive_get (GDBusProxy *proxy, const char *message, gint32 fallback)
+{
+	gint32 result = fallback;
+	GError *error = NULL;
+
+	GVariant *res = g_dbus_proxy_call_sync (proxy, message,
+			NULL, G_DBUS_CALL_FLAGS_NONE, -1, NULL, &error);
 
 	if (res == NULL) {
 		g_warning ("Failed to get mce keepalive period: %s", error->message);
 		g_error_free (error);
-		goto out;
+		return -1;
 	}
 
-	// Keepalive period from MCE
-	gint32 keepalive_period = 0;
 	GVariant *period = g_variant_get_child_value (res, 0);
 	if (period) {
-		keepalive_period = g_variant_get_int32 (period);
+		result = g_variant_get_int32 (period);
 		g_variant_unref (period);
 	}
 
-	if (keepalive_period > 0) {
-		g_debug ("Got keepalive period from mce: %u seconds", keepalive_period);
-	} else {
-		keepalive_period = 60;
+	if (result <= 0) {
 		gchar *tmp = g_variant_print(res, TRUE);
 		g_warning ("Got bogus keepalive period (%s), falling back to %u seconds",
-				tmp, keepalive_period);
+				tmp, fallback);
 		g_free (tmp);
+
+		result = fallback;
+	} else {
+		g_debug ("Got keepalive period from mce: %u seconds", result);
 	}
+
 	g_variant_unref (res);
 
-	while (engine->priv->mce_thread_active) {
-		error = NULL;
-		res = g_dbus_proxy_call_sync (engine->priv->mce_proxy,
-				MCE_CPU_KEEPALIVE_START_REQ,
-				NULL,
-				G_DBUS_CALL_FLAGS_NONE,
-				-1,
-				NULL,
-				&error);
-		if (res == NULL) {
-			g_warning ("Failed to send keepalive start req: %s", error->message);
-			g_error_free (error);
-			goto out_with_stop;
-		}
-		g_variant_unref (res);
+	return result;
+}
 
-		// Exit immediately after the D-Bus call if there has been a
-		// shutdown request in the meantime (without waiting for cond)
-		if (!engine->priv->mce_thread_active) {
-			break;
+static void
+mce_keepalive_wait (PkEnginePrivate *priv, gint32 period)
+{
+	g_mutex_lock(&(priv->mce_mutex));
+
+	if (priv->mce_thread_active) {
+		gint64 end_time = g_get_monotonic_time () +
+			period * G_TIME_SPAN_SECOND;
+
+		g_cond_wait_until (&(priv->mce_cond),
+				&(priv->mce_mutex),
+				end_time);
+	}
+
+	g_mutex_unlock(&(priv->mce_mutex));
+}
+
+static gboolean
+mce_keepalive_thread_get_active (PkEnginePrivate *priv)
+{
+	gboolean result = FALSE;
+
+	g_mutex_lock(&(priv->mce_mutex));
+	result = priv->mce_thread_active;
+	g_mutex_unlock(&(priv->mce_mutex));
+
+	return result;
+}
+
+static void
+mce_keepalive_thread_set_active (PkEnginePrivate *priv, gboolean active)
+{
+	g_mutex_lock(&(priv->mce_mutex));
+	priv->mce_thread_active = active;
+	g_mutex_unlock(&(priv->mce_mutex));
+}
+
+static gpointer
+mce_keepalive_thread_func (gpointer data)
+{
+	PkEngine *engine = PK_ENGINE (data);
+
+	// Period (in seconds) to send keepalive messages
+	gint32 keepalive_period_fallback = 60;
+	gint32 keepalive_period = keepalive_period_fallback;
+
+	// Period (in seconds) to wait between connection attempts
+	gint32 reconnect_period = 5;
+
+	// D-Bus proxy object for communicating with mce
+	GDBusProxy *proxy = NULL;
+
+	while (mce_keepalive_thread_get_active(engine->priv)) {
+		// If the proxy is not available (e.g. because we have just
+		// started or because the last request to mce failed), try to
+		// reconnect to mce every <reconnect_period> seconds
+		while (mce_keepalive_thread_get_active(engine->priv) &&
+				proxy == NULL) {
+			g_debug ("Connecting to mce");
+			proxy = mce_keepalive_connect (engine->priv->connection);
+			if (proxy != NULL) {
+				// Re-request keepalive period from mce
+				keepalive_period = mce_keepalive_get (proxy,
+						MCE_CPU_KEEPALIVE_PERIOD_REQ,
+						keepalive_period_fallback);
+
+				// Connection is still broken, wait and try again soon
+				if (keepalive_period == -1) {
+					g_warning ("Waiting for mce to come back");
+					g_object_unref (proxy);
+					proxy = NULL;
+					mce_keepalive_wait (engine->priv, reconnect_period);
+					continue;
+				}
+
+				break;
+			}
+
+		}
+
+		// Send the keepalive message once we have a proxy available
+		if (!mce_keepalive_send (proxy, MCE_CPU_KEEPALIVE_START_REQ)) {
+			// mce has gone away (due to an upgrade?) - remove proxy
+			g_warning ("Lost connection to mce");
+			g_object_unref (proxy);
+			proxy = NULL;
+			continue;
 		}
 
 		// Sleep until the next keepalive request needs sending
-		g_mutex_lock(&(engine->priv->mce_mutex));
-
-		gint64 end_time = g_get_monotonic_time () +
-			keepalive_period * G_TIME_SPAN_SECOND;
-
-		g_cond_wait_until (&(engine->priv->mce_cond),
-				&(engine->priv->mce_mutex),
-				end_time);
-
-		g_mutex_unlock(&(engine->priv->mce_mutex));
+		mce_keepalive_wait (engine->priv, keepalive_period);
 	}
 
-out_with_stop:
-	error = NULL;
-	res = g_dbus_proxy_call_sync (engine->priv->mce_proxy,
-			MCE_CPU_KEEPALIVE_STOP_REQ,
-			NULL,
-			G_DBUS_CALL_FLAGS_NONE,
-			-1,
-			NULL,
-			&error);
+	if (proxy) {
+		// We don't really care if the stop request is successful or not,
+		// in the worst case mce will time out our keepalive request after
+		// <keepalive_period> seconds; just make sure we close the thread
+		// as soon as possible to not unnecessarily block the main thread
+		mce_keepalive_send (proxy, MCE_CPU_KEEPALIVE_STOP_REQ);
 
-	if (res == NULL) {
-		g_warning ("Failed to send keepalive stop req: %s", error->message);
-		g_error_free (error);
-		goto out;
+		g_object_unref (proxy);
 	}
 
-	g_variant_unref (res);
-
-out:
 	return NULL;
 }
 #endif
@@ -550,23 +635,25 @@
 #ifdef PK_BUILD_MCE
 	if (size != 0) {
 		/* start the mce keepalive thread */
-		if (engine->priv->mce_thread == NULL) {
+		if (!mce_keepalive_thread_get_active (engine->priv)) {
 			g_debug ("Starting up the mce keepalive thread");
+			g_mutex_lock(&(engine->priv->mce_mutex));
 			engine->priv->mce_thread_active = TRUE;
 			engine->priv->mce_thread = g_thread_new("mce-keepalive-sender",
 					mce_keepalive_thread_func, engine);
+			g_mutex_unlock(&(engine->priv->mce_mutex));
 			g_debug ("The mce keepalive thread was started");
 		}
 	} else {
 		/* shut down the mce keepalive thread */
-		if (engine->priv->mce_thread_active) {
+		if (mce_keepalive_thread_get_active (engine->priv)) {
 			g_debug ("Shutting down the mce keepalive thread");
 			g_mutex_lock(&(engine->priv->mce_mutex));
 			engine->priv->mce_thread_active = FALSE;
 			g_cond_signal(&(engine->priv->mce_cond));
+			engine->priv->mce_thread = NULL;
 			g_mutex_unlock(&(engine->priv->mce_mutex));
 			g_thread_join (engine->priv->mce_thread);
-			engine->priv->mce_thread = NULL;
 			g_debug ("The mce keepalive thread was shut down");
 		}
 	}
@@ -1597,26 +1684,6 @@
 }
 #endif
 
-#ifdef PK_BUILD_MCE
-/**
- * pk_engine_proxy_mce_cb:
- **/
-static void
-pk_engine_proxy_mce_cb (GObject *source_object,
-			GAsyncResult *res,
-			gpointer user_data)
-{
-	GError *error = NULL;
-	PkEngine *engine = PK_ENGINE (user_data);
-
-	engine->priv->mce_proxy = g_dbus_proxy_new_finish (res, &error);
-	if (engine->priv->mce_proxy == NULL) {
-		g_warning ("failed to connect to mce: %s", error->message);
-		g_error_free (error);
-	}
-}
-#endif
-
 /**
  * pk_engine_on_bus_acquired_cb:
  **/
@@ -1647,19 +1714,6 @@
 			  "org.freedesktop.login1.Manager",
 			  NULL, /* GCancellable */
 			  pk_engine_proxy_logind_cb,
-			  engine);
-#endif
-
-#ifdef PK_BUILD_MCE
-	/* connect to mce */
-	g_dbus_proxy_new (connection,
-			  G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES,
-			  NULL,
-			  MCE_SERVICE,
-			  MCE_REQUEST_PATH,
-			  MCE_REQUEST_IF,
-			  NULL, /* GCancellable */
-			  pk_engine_proxy_mce_cb,
 			  engine);
 #endif
 
