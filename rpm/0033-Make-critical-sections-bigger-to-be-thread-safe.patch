From 58571b2074a8f33f13708192bb4afea8be46a574 Mon Sep 17 00:00:00 2001
From: Thomas Perl <thomas.perl@jolla.com>
Date: Mon, 13 Jan 2014 10:04:06 +0100
Subject: [PATCH 33/65] Make critical sections bigger to be thread safe

---
 src/pk-engine.c | 52 +++++++++++++++++-----------------------------------
 1 file changed, 17 insertions(+), 35 deletions(-)

diff --git a/src/pk-engine.c b/src/pk-engine.c
index 4c13bf517..cf683794a 100644
--- a/src/pk-engine.c
+++ b/src/pk-engine.c
@@ -255,8 +255,6 @@ mce_keepalive_get (GDBusProxy *proxy, const char *message, gint32 fallback)
 static void
 mce_keepalive_wait (PkEnginePrivate *priv, gint32 period)
 {
-	g_mutex_lock(&(priv->mce_mutex));
-
 	if (priv->mce_thread_active) {
 		gint64 end_time = g_get_monotonic_time () +
 			period * G_TIME_SPAN_SECOND;
@@ -265,28 +263,6 @@ mce_keepalive_wait (PkEnginePrivate *priv, gint32 period)
 				&(priv->mce_mutex),
 				end_time);
 	}
-
-	g_mutex_unlock(&(priv->mce_mutex));
-}
-
-static gboolean
-mce_keepalive_thread_get_active (PkEnginePrivate *priv)
-{
-	gboolean result = FALSE;
-
-	g_mutex_lock(&(priv->mce_mutex));
-	result = priv->mce_thread_active;
-	g_mutex_unlock(&(priv->mce_mutex));
-
-	return result;
-}
-
-static void
-mce_keepalive_thread_set_active (PkEnginePrivate *priv, gboolean active)
-{
-	g_mutex_lock(&(priv->mce_mutex));
-	priv->mce_thread_active = active;
-	g_mutex_unlock(&(priv->mce_mutex));
 }
 
 static gpointer
@@ -304,12 +280,12 @@ mce_keepalive_thread_func (gpointer data)
 	// D-Bus proxy object for communicating with mce
 	GDBusProxy *proxy = NULL;
 
-	while (mce_keepalive_thread_get_active(engine->priv)) {
+	g_mutex_lock (&(engine->priv->mce_mutex));
+	while (engine->priv->mce_thread_active) {
 		// If the proxy is not available (e.g. because we have just
 		// started or because the last request to mce failed), try to
 		// reconnect to mce every <reconnect_period> seconds
-		while (mce_keepalive_thread_get_active(engine->priv) &&
-				proxy == NULL) {
+		while (engine->priv->mce_thread_active && proxy == NULL) {
 			g_debug ("Connecting to mce");
 			proxy = mce_keepalive_connect (engine->priv->connection);
 			if (proxy != NULL) {
@@ -323,6 +299,7 @@ mce_keepalive_thread_func (gpointer data)
 					g_warning ("Waiting for mce to come back");
 					g_object_unref (proxy);
 					proxy = NULL;
+					// Mutex will be unlocked for the duration of the wait
 					mce_keepalive_wait (engine->priv, reconnect_period);
 					continue;
 				}
@@ -342,8 +319,10 @@ mce_keepalive_thread_func (gpointer data)
 		}
 
 		// Sleep until the next keepalive request needs sending
+		// (mutex will be unlocked for the duration of the wait)
 		mce_keepalive_wait (engine->priv, keepalive_period);
 	}
+	g_mutex_unlock (&(engine->priv->mce_mutex));
 
 	if (proxy) {
 		// We don't really care if the stop request is successful or not,
@@ -635,26 +614,29 @@ pk_engine_get_seconds_idle (PkEngine *engine)
 #ifdef PK_BUILD_MCE
 	if (size != 0) {
 		/* start the mce keepalive thread */
-		if (!mce_keepalive_thread_get_active (engine->priv)) {
+		g_mutex_lock (&(engine->priv->mce_mutex));
+		if (!engine->priv->mce_thread_active) {
 			g_debug ("Starting up the mce keepalive thread");
-			g_mutex_lock(&(engine->priv->mce_mutex));
 			engine->priv->mce_thread_active = TRUE;
 			engine->priv->mce_thread = g_thread_new("mce-keepalive-sender",
 					mce_keepalive_thread_func, engine);
-			g_mutex_unlock(&(engine->priv->mce_mutex));
 			g_debug ("The mce keepalive thread was started");
 		}
+		g_mutex_unlock (&(engine->priv->mce_mutex));
 	} else {
 		/* shut down the mce keepalive thread */
-		if (mce_keepalive_thread_get_active (engine->priv)) {
+		g_mutex_lock (&(engine->priv->mce_mutex));
+		if (engine->priv->mce_thread_active) {
 			g_debug ("Shutting down the mce keepalive thread");
-			g_mutex_lock(&(engine->priv->mce_mutex));
 			engine->priv->mce_thread_active = FALSE;
-			g_cond_signal(&(engine->priv->mce_cond));
-			engine->priv->mce_thread = NULL;
-			g_mutex_unlock(&(engine->priv->mce_mutex));
+			g_cond_signal (&(engine->priv->mce_cond));
+			g_mutex_unlock (&(engine->priv->mce_mutex));
 			g_thread_join (engine->priv->mce_thread);
+			engine->priv->mce_thread = NULL;
 			g_debug ("The mce keepalive thread was shut down");
+		} else {
+			// Thread is not active - just unlock the mutex
+			g_mutex_unlock (&(engine->priv->mce_mutex));
 		}
 	}
 #endif
-- 
2.13.5

